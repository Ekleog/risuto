use crate::{search, Comment, DbDump, Task};

use pest::Parser;
use risuto_api::Query;

pub trait QueryExt {
    fn from_search(db: &DbDump, search: &str) -> Query;
    fn matches(&self, task: &Task) -> bool;
}

impl QueryExt for Query {
    fn from_search(db: &DbDump, search: &str) -> Query {
        tracing::trace!(?search, "parsing query");
        let res = match search::Parser::parse(search::Rule::everything, search) {
            Ok(mut pairs) => {
                // ignore the Pair generated by EOI
                let search_res = pairs
                    .next()
                    .expect("Rule::everything result without search result");
                search::parse_search(db, search_res.into_inner())
            }
            e => todo!("should have proper error handling here: {:?}", e),
        };
        tracing::trace!(?search, ?res, "parsed query");
        res
    }

    fn matches(&self, task: &Task) -> bool {
        let tokenized = has_fts(self).then(|| tokenize_task(task));
        matches_impl(self, task, &tokenized)
    }
}

fn has_fts(q: &Query) -> bool {
    match q {
        Query::Any(q) => q.iter().any(|q| has_fts(q)),
        Query::All(q) => q.iter().any(|q| has_fts(q)),
        Query::Not(q) => has_fts(q),
        Query::Archived(_) => false,
        Query::Done(_) => false,
        Query::Tag { .. } => false,
        Query::Phrase(_) => true,
    }
}

fn matches_impl(q: &Query, task: &Task, tokenized: &Option<Vec<Vec<String>>>) -> bool {
    match q {
        Query::Any(q) => q.iter().any(|q| matches_impl(q, task, tokenized)),
        Query::All(q) => q.iter().all(|q| matches_impl(q, task, tokenized)),
        Query::Not(q) => !matches_impl(q, task, tokenized),
        Query::Archived(a) => task.is_archived == *a,
        Query::Done(d) => task.is_done == *d,
        Query::Tag { tag, backlog } => match task.current_tags.get(tag) {
            None => false,
            Some(info) => match backlog {
                None => true,
                Some(b) => *b == info.backlog,
            },
        },
        Query::Phrase(p) => {
            let q = tokenize(p);
            if q.is_empty() {
                return true; // query consisting of nothing but stop-words
            }
            let tokenized = tokenized.as_ref().expect(
                "called matched_impl on query that has fts without providing tokenized text",
            );
            for text in tokenized {
                if text.windows(q.len()).any(|w| w == q) {
                    return true;
                }
            }
            false
        }
    }
}

/// Returns a Vec<String> for the title and one per comment, where each String is a token
// TODO: this should be cached in-memory at the time of db dump receiving maybe?
fn tokenize_task(task: &Task) -> Vec<Vec<String>> {
    let mut res = Vec::with_capacity(1 + task.current_comments.len());
    res.push(tokenize(&task.current_title));
    fn also_tokenize_comment(c: &Comment, res: &mut Vec<Vec<String>>) {
        res.push(tokenize(
            &c.edits
                .last_key_value()
                .expect("comment with no edits")
                .1
                .last()
                .expect("comment-edit btreemap entry with no edit"),
        ));
        for child in c.children.values().flat_map(|c| c.iter()) {
            also_tokenize_comment(&child, &mut *res);
        }
    }
    for c in task.current_comments.values().flat_map(|c| c.iter()) {
        also_tokenize_comment(&c, &mut res);
    }
    res
}

fn tokenize(s: &str) -> Vec<String> {
    use tantivy::tokenizer::*;
    let tokenizer = TextAnalyzer::from(SimpleTokenizer)
        .filter(RemoveLongFilter::limit(40))
        .filter(LowerCaser)
        .filter(AsciiFoldingFilter)
        .filter(Stemmer::new(Language::English)) // TODO: make this configurable
        .filter(StopWordFilter::new(Language::English).unwrap());
    let mut stream = tokenizer.token_stream(s);
    let mut res = Vec::new();
    while stream.advance() {
        let token = stream.token_mut();
        res.push(std::mem::replace(&mut token.text, String::new()));
    }
    res
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::api::*;
    use std::collections::HashMap;

    fn example_db() -> DbDump {
        let mut tags = HashMap::new();
        tags.insert(
            TagId(Uuid::new_v4()),
            (
                Tag {
                    id: TagId::stub(),
                    owner_id: UserId::stub(),
                    name: String::from("foo"),
                    archived: false,
                },
                AuthInfo::all(),
            ),
        );
        tags.insert(
            TagId(Uuid::new_v4()),
            (
                Tag {
                    id: TagId::stub(),
                    owner_id: UserId::stub(),
                    name: String::from("bar"),
                    archived: false,
                },
                AuthInfo::all(),
            ),
        );
        tags.insert(
            TagId(Uuid::new_v4()),
            (
                Tag {
                    id: TagId::stub(),
                    owner_id: UserId::stub(),
                    name: String::from("baz"),
                    archived: false,
                },
                AuthInfo::all(),
            ),
        );
        DbDump {
            owner: UserId::stub(),
            users: HashMap::new(),
            tags,
            tasks: HashMap::new(),
        }
    }

    fn phrase(s: &str) -> Query {
        Query::Phrase(s.to_string())
    }

    #[test]
    fn primary_archived() {
        let db = example_db();
        assert_eq!(
            Query::from_search(&db, "archived:true"),
            Query::Archived(true),
        );
        assert_eq!(
            Query::from_search(&db, "archived:false"),
            Query::Archived(false),
        );
    }

    #[test]
    fn primary_done() {
        let db = example_db();
        assert_eq!(Query::from_search(&db, "done:true"), Query::Done(true),);
        assert_eq!(Query::from_search(&db, "done:false"), Query::Done(false),);
    }

    #[test]
    fn primary_tag() {
        let db = example_db();
        assert_eq!(
            Query::from_search(&db, "tag:foo"),
            Query::tag(db.tag_id("foo").unwrap()),
        );
        assert_eq!(
            Query::from_search(&db, "tag:bar"),
            Query::tag(db.tag_id("bar").unwrap()),
        );
        // TODO: also test behavior for unknown tag
    }

    #[test]
    fn primary_word() {
        let db = example_db();

        // Basic words (including tag name)
        assert_eq!(Query::from_search(&db, "test"), phrase("test"),);
        assert_eq!(Query::from_search(&db, "foo"), phrase("foo"),);

        // Words matching special query parameters
        assert_eq!(Query::from_search(&db, "archived"), phrase("archived"),);
        assert_eq!(Query::from_search(&db, "tag"), phrase("tag"),);
    }

    #[test]
    fn primary_phrase() {
        let db = example_db();

        // Basic usage
        assert_eq!(Query::from_search(&db, r#""test""#), phrase("test"),);
        assert_eq!(Query::from_search(&db, r#""foo bar""#), phrase("foo bar"),);

        // Things that look like queries
        assert_eq!(
            Query::from_search(&db, r#""(foo bar OR archived:false)""#),
            phrase("(foo bar OR archived:false)"),
        );
        assert_eq!(Query::from_search(&db, r#""(test""#), phrase("(test"),);

        // Escapes
        assert_eq!(
            Query::from_search(&db, r#""foo\" bar""#),
            phrase(r#"foo" bar"#),
        );
        assert_eq!(
            Query::from_search(&db, r#""foo\\ bar""#),
            phrase(r#"foo\ bar"#),
        );
        assert_eq!(
            Query::from_search(&db, r#""foo\\\" bar""#),
            phrase(r#"foo\" bar"#),
        );
    }

    #[test]
    fn infixes() {
        let db = example_db();

        // Nothing is and
        assert_eq!(
            Query::from_search(&db, "foo bar"),
            Query::All(vec![phrase("foo"), phrase("bar")]),
        );
        assert_eq!(
            Query::from_search(&db, r#""foo bar" "baz""#),
            Query::All(vec![phrase("foo bar"), phrase("baz")]),
        );

        // Explicit and
        assert_eq!(
            Query::from_search(&db, "foo AND archived:false"),
            Query::All(vec![phrase("foo"), Query::Archived(false)]),
        );

        // Explicit or
        assert_eq!(
            Query::from_search(&db, "foo or archived:false"),
            Query::Any(vec![phrase("foo"), Query::Archived(false)]),
        );
    }

    #[test]
    fn complex() {
        let db = example_db();
        assert_eq!(
            Query::from_search(&db, "foo bar baz"),
            Query::All(vec![phrase("foo"), phrase("bar"), phrase("baz")]),
        );
        assert_eq!(
            Query::from_search(&db, "foo bar or baz"),
            Query::All(vec![
                phrase("foo"),
                Query::Any(vec![phrase("bar"), phrase("baz")])
            ]),
        );
        assert_eq!(
            Query::from_search(&db, "(foo bar) or baz"),
            Query::Any(vec![
                Query::All(vec![phrase("foo"), phrase("bar")]),
                phrase("baz")
            ]),
        );
        assert_eq!(
            Query::from_search(&db, "(archived:true bar) or baz"),
            Query::Any(vec![
                Query::All(vec![Query::Archived(true), phrase("bar")]),
                phrase("baz")
            ]),
        );
    }
}
